diff --git a/src/exp4b/include/sched.h b/src/exp4b/include/sched.h
index 3885ee3..d1671af 100644
--- a/src/exp4b/include/sched.h
+++ b/src/exp4b/include/sched.h
@@ -18,6 +18,10 @@ extern struct task_struct *current;
 extern struct task_struct * task[NR_TASKS];
 extern int nr_tasks;
 
+extern struct message_struct * tmp_msg_struct;
+extern int switch_count;
+extern struct message_struct * messages[50];
+
 struct cpu_context {
 	unsigned long x19;
 	unsigned long x20;
@@ -42,6 +46,18 @@ struct task_struct {
 	long preempt_count;
 };
 
+struct message_struct {
+	unsigned long timestamp;
+	int pid_in;
+	int pid_out;
+
+	long pc_in;
+	long pc_out;
+
+	long sp_in;
+	long sp_out;
+};
+
 extern void sched_init(void);
 extern void schedule(void);
 extern void timer_tick(void);
@@ -50,6 +66,22 @@ extern void preempt_enable(void);
 extern void switch_to(struct task_struct* next);
 extern void cpu_switch_to(struct task_struct* prev, struct task_struct* next);
 
+extern int getpid(void);
+extern void print_msg(struct message_struct * tmp_msg_struct);
+extern void increment_switch_count(void);
+extern int get_switch_count(void);
+extern void record_timestamp(void);
+extern void store_message(void);
+extern void store_current_sp_pc(long sp, long pc);
+extern void store_incoming_sp_pc(long sp, long pc);
+extern void store_current_pid(void);
+extern void store_next_pid(void);
+extern void print_msgs(void );
+
+#define INIT_MSG {\
+	0, 0, 0, 0, 0, 0, 0\
+}
+
 #define INIT_TASK \
 /*cpu_context*/	{ {0,0,0,0,0,0,0,0,0,0,0,0,0}, \
 /* state etc */	0,0,1, 0 \
diff --git a/src/exp4b/include/timer.h b/src/exp4b/include/timer.h
index 83529c1..af8f8bf 100644
--- a/src/exp4b/include/timer.h
+++ b/src/exp4b/include/timer.h
@@ -9,5 +9,6 @@ void handle_generic_timer_irq ( void );
 
 extern void gen_timer_init();
 extern void gen_timer_reset(int interval);
+extern unsigned long get_time_ms(void);
 
 #endif  /*_TIMER_H */
diff --git a/src/exp4b/src/entry.S b/src/exp4b/src/entry.S
index c85164f..77f6c85 100644
--- a/src/exp4b/src/entry.S
+++ b/src/exp4b/src/entry.S
@@ -37,6 +37,11 @@
 
 	stp	x30, x22, [sp, #16 * 15] 
 	str	x23, [sp, #16 * 16]
+
+	mov x0, sp 
+	mrs x1, elr_el1
+	bl store_current_sp_pc // gets the sp and the pc
+
 	.endm
 
 	.macro	kernel_exit
@@ -45,6 +50,13 @@
 
 	msr	elr_el1, x22			
 	msr	spsr_el1, x23
+	
+	// fetch sp and pc of incoming task
+	mrs x0, elr_el1
+	mov x1, sp
+	bl store_incoming_sp_pc	
+	bl print_msg
+	// bl increment_switch_count
 
 	ldp	x0, x1, [sp, #16 * 0]
 	ldp	x2, x3, [sp, #16 * 1]
@@ -61,7 +73,7 @@
 	ldp	x24, x25, [sp, #16 * 12]
 	ldp	x26, x27, [sp, #16 * 13]
 	ldp	x28, x29, [sp, #16 * 14]
-	add	sp, sp, #S_FRAME_SIZE		
+	add	sp, sp, #S_FRAME_SIZE	
 	eret
 	.endm
 
@@ -142,6 +154,7 @@ el1_irq:
 	bl	handle_irq
 	kernel_exit 
 
+
 .globl ret_from_fork
 ret_from_fork:
 	bl	schedule_tail
diff --git a/src/exp4b/src/irq.c b/src/exp4b/src/irq.c
index 1c9c98e..f11dad4 100644
--- a/src/exp4b/src/irq.c
+++ b/src/exp4b/src/irq.c
@@ -3,6 +3,7 @@
 #include "timer.h"
 #include "entry.h"
 #include "peripherals/irq.h"
+#include "sched.h"
 
 const char *entry_error_messages[] = {
     "SYNC_INVALID_EL1t",
diff --git a/src/exp4b/src/kernel.c b/src/exp4b/src/kernel.c
index ae50ca0..0a890e5 100644
--- a/src/exp4b/src/kernel.c
+++ b/src/exp4b/src/kernel.c
@@ -6,12 +6,15 @@
 #include "sched.h"
 #include "mini_uart.h"
 
+long initial_interval = 5000000;
+
+//processes
 void process(char *array)
 {
 	while (1) {
 		for (int i = 0; i < 5; i++){
 			uart_send(array[i]);
-			delay(5000000);
+			delay(initial_interval);
 		}
 	}
 }
@@ -21,7 +24,27 @@ void process2(char *array)
 	while (1) {
 		for (int i = 0; i < 5; i++){
 			uart_send(array[i]);
-			delay(5000000);
+			delay(initial_interval);
+		}
+	}
+}
+
+void process3(char *array)
+{
+	while (1) {
+		for (int i = 0; i < 5; i++){
+			uart_send(array[i]);
+			delay(initial_interval);
+		}
+	}
+}
+
+void process4(char *array)
+{
+	while (1) {
+		for (int i = 0; i < 5; i++){
+			uart_send(array[i]);
+			delay(initial_interval);
 		}
 	}
 }
@@ -38,18 +61,41 @@ void kernel_main(void)
 	enable_interrupt_controller();
 	enable_irq();
 
-	int res = copy_process((unsigned long)&process, (unsigned long)"12345");
+	//creates the processes
+	int res = copy_process((unsigned long)&process, (unsigned long)"12345"); // process 1
 	if (res != 0) {
 		printf("error while starting process 1");
 		return;
 	}
-	res = copy_process((unsigned long)&process2, (unsigned long)"abcde");
+	res = copy_process((unsigned long)&process2, (unsigned long)"abcde"); //process 2
 	if (res != 0) {
 		printf("error while starting process 2");
 		return;
 	}
 
+	res = copy_process((unsigned long)&process3, (unsigned long)"67890"); // process 3
+	if(res != 0) {
+		printf("error while starting process 3");
+		return;
+	}
+
+	res = copy_process((unsigned long)&process4, (unsigned long)"fghij"); // process 4
+	if(res != 0) {
+		printf("error while starting process 4");
+		return;
+	}
+
 	while (1){
 		schedule();
+		if(switch_count == 50) { // printing
+			for(int i = 0; i < 50; i++) {
+				print_msg(messages[i]);
+			}
+			delay(5000000);
+		}
 	}	
+
+
 }
+
+
diff --git a/src/exp4b/src/sched.c b/src/exp4b/src/sched.c
index 7fbf9fc..9cb0a1b 100644
--- a/src/exp4b/src/sched.c
+++ b/src/exp4b/src/sched.c
@@ -1,12 +1,20 @@
 #include "sched.h"
 #include "irq.h"
 #include "printf.h"
+#include "timer.h"
 
 static struct task_struct init_task = INIT_TASK;
 struct task_struct *current = &(init_task);
 struct task_struct * task[NR_TASKS] = {&(init_task), };
 int nr_tasks = 1;
 
+int next_pid = 1;
+int current_pid = 0;
+int switch_count = 0; // keep track of the number of switches
+struct message_struct * messages[50] = {};
+static struct message_struct init_msg = INIT_MSG;
+struct message_struct * tmp_msg_struct =&(init_msg);
+
 void preempt_disable(void)
 {
 	current->preempt_count++;
@@ -24,7 +32,7 @@ void _schedule(void)
 		we still leave irq on, because irq handler may set a task to be TASK_RUNNING, which 
 		will be picked up by the scheduler below */
 	preempt_disable(); 
-	int next,c;
+	int next, c;
 	struct task_struct * p;
 	while (1) {
 		c = -1; // the maximum counter of all tasks 
@@ -58,13 +66,19 @@ void _schedule(void)
 			}
 		}
 	}
+	
+	store_current_pid();
+	current_pid = next;
 	switch_to(task[next]);
 	preempt_enable();
+	store_message();
+
 }
 
 void schedule(void)
 {
 	current->counter = 0;
+
 	_schedule();
 }
 
@@ -88,11 +102,19 @@ void switch_to(struct task_struct * next)
 			80d58:       9400083b        bl      82e44 <cpu_switch_to>
 		==> 80d5c:       14000002        b       80d64 <switch_to+0x58>
 	*/
+	record_timestamp();
+	increment_switch_count();
 	cpu_switch_to(prev, next);  /* will branch to @next->cpu_context.pc ...*/
+	store_next_pid();
+
+	// if(switch_count == 10) {
+	// 	printf("Switch Count is now 10\n");
+	// }
 }
 
 void schedule_tail(void) {
 	preempt_enable();
+
 }
 
 
@@ -109,4 +131,56 @@ void timer_tick()
 	_schedule();
 	/* disable irq until kernel_exit, in which eret will resort the interrupt flag from spsr, which sets it on. */
 	disable_irq(); 
+
+}
+
+// get pid of current task
+int getpid(void) {
+	return current_pid;
+}
+
+
+// STORE INTO THE MSG STRUCT
+void increment_switch_count(void) {
+	switch_count++;
+}
+
+
+void print_msg( struct message_struct * msg_struct ) {
+
+	//sample message: 1234 from task1 (PC 0x81000 SP 0x83F00) to task2 (PC 0x82000 SP 0x85F00)
+	printf("%d from task%d (PC %x SP %x) to task%d (PC %x SP %x)\n", msg_struct -> timestamp, msg_struct -> pid_in, msg_struct -> pc_in,
+	msg_struct -> sp_in, msg_struct -> pid_out, msg_struct -> pc_out, msg_struct -> sp_out);
+}
+
+	//TODO: store the timestamp
+void record_timestamp(void) {
+	tmp_msg_struct -> timestamp = get_time_ms(); 
+}
+
+void store_message(void) {
+	struct message_struct m = * tmp_msg_struct; 
+	messages[switch_count - 1] = &m;
+}
+
+void store_current_sp_pc(long sp, long pc) {
+	tmp_msg_struct -> sp_in = sp;
+	tmp_msg_struct -> pc_in = pc;
 }
+
+void store_incoming_sp_pc(long pc, long sp) {
+	tmp_msg_struct -> sp_out = sp;
+	tmp_msg_struct -> pc_out = pc;
+}
+
+void store_current_pid(void) {
+	tmp_msg_struct -> pid_in = getpid();
+}
+
+void store_next_pid(void) {
+	tmp_msg_struct -> pid_out = getpid();
+}
+
+void print_msgs(void ) {
+	printf("message.....");
+}
\ No newline at end of file
diff --git a/src/exp4b/src/timer.c b/src/exp4b/src/timer.c
index 4c09244..6df03c0 100644
--- a/src/exp4b/src/timer.c
+++ b/src/exp4b/src/timer.c
@@ -23,10 +23,21 @@ void generic_timer_init ( void )
 
 void handle_generic_timer_irq( void ) 
 {
+	interval = 1 * 1000 * 100; // interval is now 100ms
 	gen_timer_reset(interval);
     timer_tick();
 }
 
+unsigned long get_time_ms(void) { //returns the elapsed time 
+	unsigned long low_tick = get32(TIMER_CLO);
+	unsigned long high_tick = get32(TIMER_CHI);
+
+	unsigned long current_tick = (high_tick << 32) + (low_tick);
+
+	return current_tick / 1000;
+}
+
+
 /* 
 	These are for "System Timer". They are NOT in use by this project. 
 	I leave the code here FYI. 
@@ -51,4 +62,5 @@ void handle_timer_irq( void )
 	put32(TIMER_C1, curVal);
 	put32(TIMER_CS, TIMER_CS_M1);
 	timer_tick();
-}
\ No newline at end of file
+}
+
