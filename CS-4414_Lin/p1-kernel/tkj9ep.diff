diff --git a/src/exp4a/include/sched.h b/src/exp4a/include/sched.h
index 62f841b..78be44c 100644
--- a/src/exp4a/include/sched.h
+++ b/src/exp4a/include/sched.h
@@ -21,6 +21,7 @@
 	TASK_RUNNING represents either RUNNING or READY 
 */
 #define TASK_RUNNING				0
+#define TASK_WAIT					1
 /* TODO: define more task states (as constants) below, e.g. TASK_WAIT */
 
 extern struct task_struct *current;
@@ -51,6 +52,7 @@ struct task_struct {
 	long counter;	// how long this task has been running? decreases by 1 each timer tick. Reaching 0, kernel will attempt to schedule another task. Support our simple sched
 	long priority;	// when kernel schedules a new task, the kernel copies the task's  `priority` value to `counter`. Regulate CPU time the task gets relative to other tasks 
 	long preempt_count; // a flag. A non-zero means that the task is executing in a critical code region cannot be interrupted, Any timer tick should be ignored and not triggering rescheduling
+	long wait; // waiting queue for multiple 
 };
 
 extern void sched_init(void);
@@ -60,6 +62,7 @@ extern void schedule(void);
 //extern void preempt_enable(void);
 extern void switch_to(struct task_struct* next);
 extern void cpu_switch_to(struct task_struct* prev, struct task_struct* next);
+void sleep(int t);
 
 // the initial values for task_struct that belongs to the init task. see sched.c 
 #define INIT_TASK 									\
diff --git a/src/exp4a/include/timer.h b/src/exp4a/include/timer.h
index a346589..40c1e70 100644
--- a/src/exp4a/include/timer.h
+++ b/src/exp4a/include/timer.h
@@ -12,5 +12,7 @@ void handle_generic_timer_irq ( void );
 extern void gen_timer_init();
 /* set timer to be fired after @interval System ticks */
 extern void gen_timer_reset(int interval); 
+extern struct task_struct *current;
+extern void _schedule(void);
 
 #endif  /*_TIMER_H */
diff --git a/src/exp4a/src/kernel.c b/src/exp4a/src/kernel.c
index 76a8598..03ed0ee 100644
--- a/src/exp4a/src/kernel.c
+++ b/src/exp4a/src/kernel.c
@@ -16,8 +16,9 @@
 #define CHAR_DELAY (1000000)
 #endif
 
-void process(char *array)
-{
+int flag = 1;
+
+void process(char *array) { // processes for printing arrays
 #ifdef USE_LFB // (optional) determine the init locations on the graphical console
 	int scr_x, scr_y; 
 	char c; 
@@ -40,6 +41,39 @@ void process(char *array)
 #endif
 			delay(CHAR_DELAY);
 		} 
+		sleep(2);
+		schedule(); // yield
+	}
+
+	// For now, all the tasks run in an infinite loop and never returns. 
+	// We will handle task termination in future experiments
+}
+
+
+void process1(char *array) { // processes for printing arrays TESTING PROCESS
+#ifdef USE_LFB // (optional) determine the init locations on the graphical console
+	int scr_x, scr_y; 
+	char c; 
+	if (array[0] == '1') {
+		scr_x = 0; scr_y = 320; 
+	} else {
+		scr_x = 0; scr_y = 480; 
+	}
+#endif 
+	
+	while (1){
+		for (int i = 0; i < 5; i++){
+			uart_send(array[i]);
+#ifdef USE_LFB  // (optional) output to the graphical console
+			c = array[i+1]; array[i+1]='\0';
+			lfb_print_update(&scr_x, &scr_y, array+i);
+			array[i+1] = c; 
+			if (scr_x > 1024)
+				lfb_print_update(&scr_x, &scr_y, "\n");
+#endif
+			delay(CHAR_DELAY);
+		} 
+		sleep(5);
 		schedule(); // yield
 	}
 
@@ -47,11 +81,11 @@ void process(char *array)
 	// We will handle task termination in future experiments
 }
 
+
 void kernel_main(void)
 {
 	uart_init();
 	init_printf(0, putc);
-
 	printf("kernel boots\r\n");	
 
 	// Below, irq is off by default, b/c it is not needed for cooperative scheduling as
@@ -60,7 +94,8 @@ void kernel_main(void)
 	irq_vector_init();
 	generic_timer_init();
 	enable_interrupt_controller();
-	disable_irq();		
+	// disable_irq();
+	enable_irq();		
 
 #ifdef USE_LFB // (optional) init output to the graphical console
 	lfb_init(); 
@@ -68,12 +103,12 @@ void kernel_main(void)
 	lfb_print(0, 240, "kernel boots");
 #endif		
 
-	int res = copy_process((unsigned long)&process, (unsigned long)"12345");
+	int res = copy_process((unsigned long)&process1, (unsigned long)"12345");
 	if (res != 0) {
 		printf("error while starting process 1");
 		return;
 	}
-	
+
 	res = copy_process((unsigned long)&process, (unsigned long)"abcde");
 	if (res != 0) {
 		printf("error while starting process 2");
@@ -82,5 +117,8 @@ void kernel_main(void)
 
 	while (1) {
 		schedule();
+		printf("Will execute wfi...");
+		asm("wfi");
 	}	
 }
+ 
\ No newline at end of file
diff --git a/src/exp4a/src/sched.c b/src/exp4a/src/sched.c
index 6d38e06..0412524 100644
--- a/src/exp4a/src/sched.c
+++ b/src/exp4a/src/sched.c
@@ -1,14 +1,16 @@
 #include "sched.h"
 #include "irq.h"
 #include "printf.h"
+#include "timer.h"
 
 static struct task_struct init_task = INIT_TASK; // the very first task with its task_struct values
 struct task_struct *current = &(init_task);		 // points to the currently running task. when kernel boots, sets to init_task
-struct task_struct * task[NR_TASKS] = {&(init_task), }; // holds all task_strcuts. only has init_ask at beginning
+struct task_struct * task[NR_TASKS] = {&(init_task), }; // holds all task_strcuts. only has init_task at beginning
 int nr_tasks = 1;
 
 void _schedule(void)
 {
+
 	int next, c;
 	struct task_struct * p;
 	while (1) {
@@ -26,6 +28,7 @@ void _schedule(void)
 				c = p->counter;
 				next = i;
 			}
+
 		}
 		if (c) {	/* found a RUNNING/READY task w/ the most positive counter.  NB: c won't be -1 as counter always nonnegative */
 			break;
@@ -37,6 +40,7 @@ void _schedule(void)
 		Hence, we recharge counters. Bump counters for all tasks once. */
 		for (int i = 0; i < NR_TASKS; i++) {
 			p = task[i];
+
 			if (p) {
 				p->counter = (p->counter >> 1) + p->priority; // The increment depends on a task's priority.
 			}
@@ -67,3 +71,9 @@ void schedule_tail(void) {
 	/* nothing */
 }
 
+void sleep(int t) { // sleep function
+	// current state to WAIT
+	current -> state = TASK_WAIT;
+	current -> wait = t;
+	
+}
\ No newline at end of file
diff --git a/src/exp4a/src/timer.c b/src/exp4a/src/timer.c
index d487c5f..e8fdd6f 100644
--- a/src/exp4a/src/timer.c
+++ b/src/exp4a/src/timer.c
@@ -19,10 +19,54 @@ void generic_timer_init ( void )
 	gen_timer_init();
 }
 
-void handle_generic_timer_irq( void ) 
-{
+void handle_generic_timer_irq( void ) {
+
 	// TODO: In order to implement sleep(t), you should calculate @interval based on t, 
 	// instead of having a fixed @interval which triggers periodic interrupts
-	gen_timer_reset(interval);	
+
+	int lowest_t = 1; 
+	struct task_struct *p;
+	
+	for(int i = 0; i < NR_TASKS; i++) {
+		p = task[i];
+
+		if(p -> state == TASK_WAIT) { //sets the lowest_t variable if task that is in state TASK_WAIT is detected
+			lowest_t = __INT_MAX__;
+			break;
+		}
+	}
+
+	// look for lowest wait time
+	for (int i = 0; i < NR_TASKS; i++) {
+		p = task[i];
+
+		if(p -> state == TASK_WAIT) {
+
+			if(p -> wait == 0) { // change to TASK_RUNNING if wait time is depleted
+				p -> state = TASK_RUNNING;
+	
+			}
+
+			if(p -> state == TASK_WAIT && p -> wait < lowest_t) {
+				lowest_t = p -> wait;
+			}
+		}
+	}
+
+	//update all wait statements in the tasks
+	for(int i = 0; i < NR_TASKS; i++) {
+		if(p -> state == TASK_WAIT) {
+			p -> wait -= lowest_t;
+
+			if(p -> wait == 0) {
+				p -> state = TASK_RUNNING;
+			}
+		}
+	}
+	
+	printf("\nCurrent State is %d. Current wait value is %d. Lowest time is %d\n", p -> state, p -> wait, lowest_t);
+
+	gen_timer_reset(interval * lowest_t);
+
 	printf("Timer interrupt received. next in %u ticks\n\r", interval);
 }
