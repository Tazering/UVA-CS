diff --git a/src/exp3/src/kernel.c b/src/exp3/src/kernel.c
index a30ee1d..02776b3 100644
--- a/src/exp3/src/kernel.c
+++ b/src/exp3/src/kernel.c
@@ -22,7 +22,7 @@ void kernel_main(void)
 
 	// a = a / 0; 
 	// asm("mrs x0, elr_el2"); // will trigger exception at EL1
-	asm("hvc #0");
+	// asm("hvc #0");
 	// asm("msr	hcr_el2, x0");
 
 	// printf("going to call wfi...");
diff --git a/src/exp6/include/irq.h b/src/exp6/include/irq.h
index 3741839..2c43f5c 100644
--- a/src/exp6/include/irq.h
+++ b/src/exp6/include/irq.h
@@ -8,4 +8,7 @@ void irq_vector_init( void );
 void enable_irq( void );
 void disable_irq( void );
 
+#define SYSTEM_TIMER_IRQ_1 (1 << 1)
+
+
 #endif  /*_IRQ_H */
diff --git a/src/exp6/include/mm.h b/src/exp6/include/mm.h
index 93f07e0..cfd5bbc 100644
--- a/src/exp6/include/mm.h
+++ b/src/exp6/include/mm.h
@@ -29,7 +29,7 @@
 
 /* We use section mapping. The whole pgtable tree only needs three pgtables (each PAGE_SIZE). 
 That is, one pgtable at each of PGD/PUD/PMD. See our project document */
-#define PG_DIR_SIZE			(3 * PAGE_SIZE)  
+#define PG_DIR_SIZE			(4 * PAGE_SIZE)  
 
 #ifndef __ASSEMBLER__
 
diff --git a/src/exp6/src/boot.S b/src/exp6/src/boot.S
index 3eb1988..f18e136 100644
--- a/src/exp6/src/boot.S
+++ b/src/exp6/src/boot.S
@@ -9,7 +9,7 @@
 _start:
 	mrs	x0, mpidr_el1		
 	and	x0, x0,#0xFF		// Check processor id
-	cbz	x0, master		// Hang for all non-primary CPU
+	cbz	x0, master		// Hang for all non-primary CPU that is last 8 bits are 0
 	b	proc_hang
 
 proc_hang: 
@@ -17,7 +17,7 @@ proc_hang:
 
 master:
 	ldr	x0, =SCTLR_VALUE_MMU_DISABLED
-	msr	sctlr_el1, x0		
+	msr	sctlr_el1, x0		// disables the mmu
 	
 	mrs x0, CurrentEL
   	lsr x0, x0, #2
@@ -135,6 +135,18 @@ el1_entry:
 	add	\tbl, \tbl, #PAGE_SIZE					// point @tbl to the newly create next level pgtable. programming ease
 	.endm
 
+	.macro	create_table_entry1, tbl, virt, shift, tmp1, tmp2
+	sub \tbl, \tbl, #PAGE_SIZE // since we want to start from PUD
+	lsr	\tmp1, \virt, #\shift
+	and	\tmp1, \tmp1, #PTRS_PER_TABLE - 1		// tmp1: table index
+	add	\tmp2, \tbl, #PAGE_SIZE * 2				// tmp2: addr of a next level pgtable (PUD or PMD). 
+	orr	\tmp2, \tmp2, #MM_TYPE_PAGE_TABLE		// tmp2: make a table descriptor. set bits[0:1] to 1. 
+	str	\tmp2, [\tbl, \tmp1, lsl #3]			// store descriptor (tmp2) to the current pgtable at index (tmp1)
+	add	\tbl, \tbl, #PAGE_SIZE					// point @tbl to the newly create next level pgtable. programming ease
+	add \tbl, \tbl, #PAGE_SIZE
+
+	.endm
+
 	// Populating entries in a PMD table for a given virt addr range 
 	// @tbl: a reg pointing to the PMD table
 	// @phys: the start of the physical region to be mapped
@@ -179,6 +191,7 @@ __create_idmap:
 
 __create_page_tables:
 	mov		x29, x30						// save return address
+	// stp x30, xzr, [sp, #-8]!
 
 	// clear the mem region backing pgtables
 	adrp 	x0, pg_dir
@@ -202,6 +215,20 @@ __create_page_tables:
 	ldr		x3, =(VA_START + PHYS_MEMORY_SIZE - SECTION_SIZE)	// x3 = the virtual base of the last section
 	create_block_map x0, x1, x2, x3, MMU_DEVICE_FLAGS, x4
 
+
+	/* Set up the second PMD Table */
+	ldr 	x1, =(VA_START + PHYS_MEMORY_SIZE)
+	create_table_entry1 x0, x1, PUD_SHIFT x2, x3
+
+	// /* Mapping kernel and init stack. Phys addr range: PHYS_MEMORY_SIZE(0x40000000) --SOME LARGE VALUE */
+	// mov 	x1, xzr				// x1 = starting phys addr. set x1 to 0. 
+	ldr		x1, =(PHYS_MEMORY_SIZE)
+	ldr 	x2, =(VA_START	+ PHYS_MEMORY_SIZE)	// x2 = the virtual base of the first section
+	ldr		x3, =((VA_START + DEVICE_BASE - SECTION_SIZE) + PHYS_MEMORY_SIZE)  // x3 = the virtual base of the last section
+	// ldr 	x2, =(VA_START + PHYS_MEMORY_SIZE - SECTION_SIZE) // x2 = the virtual base of the second section
+	// ldr		x3, =((VA_START + PHYS_MEMORY_SIZE - SECTION_SIZE) + DEVICE_BASE - SECTION_SIZE)  // x3 = the virtual base of the last section
+	create_block_map x0, x1, x2, x3, MMU_FLAGS, x4
+
 	mov	x30, x29						// restore return address
 	ret
 
diff --git a/src/exp6/src/irq.c b/src/exp6/src/irq.c
index cbf2531..a597f01 100644
--- a/src/exp6/src/irq.c
+++ b/src/exp6/src/irq.c
@@ -28,10 +28,10 @@ const char *entry_error_messages[] = {
 
 void enable_interrupt_controller()
 {
-	put32(ENABLE_IRQS_1, SYSTEM_TIMER_IRQ_1);
+	// put32(ENABLE_IRQS_1, SYSTEM_TIMER_IRQ_1);
 
   // Enables Core 0 Timers interrupt control for the generic timer
-//  put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
+ 	put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
 }
 
 void show_invalid_entry_message(int type, unsigned long esr, unsigned long address)
@@ -55,10 +55,10 @@ void handle_irq(void)
 
 void handle_irq(void)
 {
-	unsigned int irq = get32(IRQ_PENDING_1);
+	unsigned int irq = get32(INT_SOURCE_0);
 	switch (irq) {
-		case (SYSTEM_TIMER_IRQ_1):
-			handle_timer_irq();
+		case (GENERIC_TIMER_INTERRUPT):
+				handle_generic_timer_irq();
 			break;
 		default:
 			printf("Inknown pending irq: %x\r\n", irq);
diff --git a/src/exp6/src/kernel.c b/src/exp6/src/kernel.c
index e59a32c..ec97dce 100644
--- a/src/exp6/src/kernel.c
+++ b/src/exp6/src/kernel.c
@@ -32,8 +32,8 @@ void kernel_main()
 	printf("kernel boots ...\n\r");
 
 	irq_vector_init();
-	timer_init();
-//	generic_timer_init();
+	//timer_init();
+	generic_timer_init();
 	enable_interrupt_controller();
 	enable_irq();
 
diff --git a/src/exp6/src/timer.c b/src/exp6/src/timer.c
index bdf4efd..8985641 100644
--- a/src/exp6/src/timer.c
+++ b/src/exp6/src/timer.c
@@ -2,8 +2,9 @@
 #include "printf.h"
 #include "sched.h"
 #include "peripherals/timer.h"
+#include "timer.h"
 
-const unsigned int interval = 200000;
+const unsigned int interval = 1 * 1000 * 100;
 unsigned int curVal = 0;
 
 /* 
@@ -34,15 +35,20 @@ void handle_timer_irq( void )
 	They are fully functional on both QEMU and Rpi3 
 */
 
-//void generic_timer_init ( void )
-//{
-//	gen_timer_init();
-//	gen_timer_reset();
-//}
-//
-//void handle_generic_timer_irq( void )
-//{
-//	gen_timer_reset();
-//	timer_tick();
-//}
+void generic_timer_init ( void )
+{
+
+	printf("interval is set to: %d\n", interval);
+
+	gen_timer_init();
+	gen_timer_reset(interval);
+
+}
+
+void handle_generic_timer_irq( void )
+{
+	printf("Timer interrupt received. next in %d ticks\n\r", interval);
+	gen_timer_reset();
+	timer_tick();
 
+}
\ No newline at end of file
diff --git a/src/experimental/exp4a-smp/include/peripherals/irq.h b/src/experimental/exp4a-smp/include/peripherals/irq.h
index 2429a6a..b0397d3 100644
--- a/src/experimental/exp4a-smp/include/peripherals/irq.h
+++ b/src/experimental/exp4a-smp/include/peripherals/irq.h
@@ -22,7 +22,7 @@
 // See BCM2836 ARM-local peripherals at
 // https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/QA7_rev3.4.pdf
 
-#define TIMER_INT_CTRL_0    (0x40000040)
+#define TIMER_INT_CTRL_0    (VA_START + 0x40000040)
 #define INT_SOURCE_0        (LPBASE+0x60)
 
 #define TIMER_INT_CTRL_0_VALUE  (1 << 1)
